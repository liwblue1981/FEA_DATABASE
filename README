1. 主文件内, 在*parameter命令下,必须有螺栓力,爆压这两个关键词,分布为F_pre_bolt以及P_dome
2. 认为必须有高温载荷步,也就是,一定会有一个载荷步有*TEMPERATURE关键词
3. 螺栓载荷是否有history output就只看第一个载荷步,所以这个信息必须在第一个载荷步进行定义,
    *OUTPUT, HISTORY
    *NODE OUTPUT,NSET=PRELOAD_NODES
    TF1,U1
4. 在第一个载荷步内查看有没有clisp, ctress的输出,如果有,才认为需要计算relative motion
    *CONTACT OUTPUT
    CSTRESS, CDISP
5. 每一种状态进行点火的缸的数目是一致的.
6. 参数定义必须位于文件头部,一次定义完毕,在后续不得再有定义,否则不会读取.
7. 还是不要写域名,有的时候未必能解析,所以会在配置文件中,写入域名所对应的IP地址.
8. 假设ODB和主文件的名字只有后缀不一样,主文件的名称,前十位字符,必须为FEA**-****的格式,这样可以便于去查询RQ.
9. 在server_location 内输入的格式为,服务器路径以及主文件名称.
10. 疲劳的内容,都由垫片文件读入,垫片文件必须包含section定义和behavior定义,所有的疲劳的单元集合对应于section下的内容,刨去BODY,stopper,假设
    这两个部分的内容只有小于8行的数据.
11. 如果疲劳设置中,没有ID,那么可以在输出的PYTHON文件中,自己来输入相应的数据,必须按照PYTHON格式输入要求.如果有ID,但是需要修改结果,也可以自行在
    PYTHON文件中修改.
12. 生成的主文件会同时拷贝两份,一份在local的位置,一份在服务器的计算文件的位置,所以,必须要有权限,否则请自行上传
13. 通常每个人只能操作自己建立的文件夹,但是我只能用我的账户来连接服务器,所以必须在计算完成后,先将文件夹属性改成都可以访问
14. 主文件,垫片文件后缀必须为inp
15. 螺栓载荷的读取,只能读取CLOAD所出现的第一个值,所有需要提取的螺栓载荷,必须放在一个集合名字下
16. 如果没有需要的疲劳数据,或者新增加了需要计算疲劳的单元集合,那么会在点击Process按钮的时候,重新从疲劳数据库中读取.读取完成后会保存为
    user_input.json格式,用户可以自行在后期进行修改,只有这一次机会.
17. 假定垫片属性定义中, TENSILE STIFFNESS FACTOR=0.001, 这个值不会被真实读入.
18. 垫片LD曲线中, 会自动根据LD的最大值来定义输出数值精度,如果最大值/点的个数 > 3,那么保留载荷小数点后一位, 否则,类似于橡胶LD,保留小数点后四位,
    位移始终保留小数点后四位
19. 发动机材料模型,只支持, ISOTROPIC的弹塑性模型,可以是温度相关,但是对于TYPE=ENGINEERING CONSTANTS, TYPE=ANISOTROPIC不支持
20. Gasket属性定义时,必须包括membrane, transverse, thicknes behavior, expansion
21. 拥有的SECTION属性,只包括SOLID, GASKET, BEAM
22. 单元号,节点号最大值不要超过9位
23. 也可以处理一面是TIE,一面是CONTACT的RELATIVE MOTION
24. 关于磨损计算,
    24.1 常规RLM, 基于节点
    24.2 常规FDP, 基于节点
    24.3 累计考虑RLM,也就是把一个循环内的RLM,考虑符号,进行求和, FIX-FIRING1, FIX-FIRING2...
    24.4 累计考虑FDP,也就是把一个循环内的FDP,考虑符号,进行求和, FIX-FIRING1, FIX-FIRING2...
    24.5 考虑单元,认为做功导致磨损,也就是假设基准状态为FIX时候的S11*E11, 变化状态为各个缸点火时候的变化,然后对这些变化进行求和.
25. bore distortion
    25.1 可以计算任意一个或多个载荷步的bore distortion.但是程序其实是处理了所有载荷步的,只是在出报告的时候,出所要求的载荷步结果
    25.2 如果在设置中,将BORE_UNIQUE_CENTER设置为False,那么会利用最小二乘法来计算圆心以及半径,并采用该半径和圆心计算distortion
    25.3 如果是自动进行bore distortion计算,那么需要创建路径,如果指定的半径所创建的路径,没有得到与设置BORE_DISTORTION_POINTS数目相同
         的插值结果,那么会自动将半径增加0.01,以便寻找到插值,如果还是没有找到,还会继续,直到计算超时,也就是半径增加0.1之后,还没有找到,会终止
         路径创建,中断程序
    25.4 对于载荷步较多的情况,不建议采用自动计算,会很耗费时间,暂时还没有考虑多线程的情况,可以看下license的使用来决定使用多少个线程同时.


